<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Climb CSV → Stacked Horizontal Bar Animation</title>
  <style>
    :root{--bg:#f7fafc;--card:#fff;--muted:#666}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg)}
    .wrap{max-width:1100px;margin:20px auto;padding:18px}
    h1{margin:0 0 10px;font-size:20px}
    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:12px}
    .card{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.06)}
    input[type=file]{display:inline-block}
    label.small{font-size:13px;color:var(--muted)}
    #chartWrap{width:100%;height:640px;display:flex;align-items:center;justify-content:center;padding:12px}
    canvas{width:100%;height:100%;max-width:100%;max-height:100%}
    button{padding:8px 10px;border-radius:6px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    a.downloadLink{font-weight:600;color:#0b5ff0}
    #status{margin-top:10px;color:#222;min-height:20px}
    .spinner{display:inline-block;width:16px;height:16px;border:2px solid #f3f3f3;border-top:2px solid #3498db;border-radius:50%;animation:spin 1s linear infinite;margin-right:8px}
    @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
    @media (max-width:720px){ #chartWrap{height:520px} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Climb CSV → Stacked Horizontal Bar Animation</h1>

    <div id="fileControls" class="controls card">
      <input id="csvFile" type="file" accept=".csv" />
    </div>

    <div id="chartWrap" class="card" style="display:none;margin-bottom:20px;">
      <canvas id="barChart"></canvas>
    </div>

    <div id="playbackControls" class="controls card" style="display:none;">
      <button id="playPauseBtn">Play</button>
      <label class="small">Frame: <input id="frameSlider" type="range" min="0" max="0" value="0" style="width:200px"/> <span id="frameDisplay">0/0</span></label>
    </div>

    <div id="status" class="card" style="margin-top:12px;padding:10px;">
      <div id="statusText">Choose a CSV file with `grade` and `color` columns (CSV header names must be `grade` and `color`). Missing color becomes "Unknown".</div>
    </div>
  </div>

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-date-fns/3.0.0/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/3.0.1/chartjs-plugin-annotation.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

  <script>
  // --- Helpers & UI refs ---
  const $ = s => document.querySelector(s);
  const statusText = $('#statusText');
  const csvFileInput = $('#csvFile');
  const playPauseBtn = $('#playPauseBtn');
  const frameSlider = $('#frameSlider');
  const frameDisplay = $('#frameDisplay');
  const canvas = document.getElementById('barChart');
  const chartWrap = $('#chartWrap');
  const playbackControls = $('#playbackControls');
  const fileControls = $('#fileControls');

  // Internal state
  let rawRows = [];
  let grades = [];
  let colors = [];
  let frames = []; // each frame: {datasets: [array per color of values-per-grade], label}
  let chart = null;
  let playTimer = null;
  let currentFrame = 0;
  let isPlaying = false;


  // --- Color mapping (common hold colors) ---
  const colorMap = {
    Pink:"#ffc0cb", Black:"#000000", Orange:"#ffa500", Purple:"#800080", White:"#ffffff",
    Blue:"#1f77b4", Red:"#d62728", Yellow:"#ffdd57", Green:"#2ca02c", Gray:"#808080",
    Grey:"#808080", Brown:"#8b4513", Tan:"#d2b48c", Gold:"#d4af37", Silver:"#c0c0c0",
    Teal:"#008080", Lime:"#32cd32", Cyan:"#00bcd4", Magenta:"#ff00ff", Beige:"#f5f5dc"
  };

  function normalizeName(s){
    if(s === undefined || s === null) return '';
    return String(s).trim();
  }

  function getColorHex(name){
    const clean = normalizeName(name);
    if(!clean) return '#cccccc';
    if(colorMap[clean]) return colorMap[clean];
    // try case-insensitive matching (e.g., 'pink' -> 'Pink')
    const key = Object.keys(colorMap).find(k => k.toLowerCase() === clean.toLowerCase());
    if(key) return colorMap[key];
    // fallback: generate consistent HSL color based on name hash
    let hash = 0;
    for(let i=0;i<clean.length;i++){ hash = clean.charCodeAt(i) + ((hash<<5)-hash); hash = hash & hash; }
    const hue = ((hash % 360) + 360) % 360;
    return `hsl(${hue} 60% 55%)`;
  }

  // parse grade like "v6", "V3", "6", return numeric; unknown -> large number
  function gradeToNumber(g){
    if(g === undefined || g === null) return Number.MAX_SAFE_INTEGER;
    const s = String(g).trim();
    const m = s.match(/(?:v)?\s*([+-]?\d+)/i);
    if(m) return parseInt(m[1],10);
    // handle things like "5+" or "5-"
    const m2 = s.match(/([0-9]+)/);
    if(m2) return parseInt(m2[1],10);
    return Number.MAX_SAFE_INTEGER;
  }

  // --- CSV auto-load on file selection ---
  csvFileInput.addEventListener('change', () => {
    const f = csvFileInput.files[0];
    if(!f) return;
    
    statusText.textContent = 'Parsing CSV...';
    Papa.parse(f, {header:true, skipEmptyLines:true,
      complete: (res) => {
        rawRows = res.data;
        try {
          prepareFramesFromCSV(rawRows);
          statusText.textContent = `Loaded ${rawRows.length} rows → ${frames.length} animation frames. Ready.`;
          
          // Hide file input and show the chart and playback controls
          fileControls.style.display = 'none';
          chartWrap.style.display = 'block';
          playbackControls.style.display = 'flex';
          
          frameSlider.max = frames.length - 1;
          frameDisplay.textContent = `1/${frames.length}`;
          currentFrame = 0;
          showFrame(0); // Show first frame
          
          // Auto-start animation
          setTimeout(() => {
            if (!isPlaying) playPauseBtn.click();
          }, 500);
        } catch(e){
          statusText.textContent = 'Error processing CSV: ' + e.message;
        }
      },
      error: (err) => {
        statusText.textContent = 'CSV parse error: ' + err.message;
      }
    });
  });

  function prepareFramesFromCSV(rows){
    if(!rows || !rows.length) throw new Error('CSV is empty.');

    // ensure header includes grade & color (case-insensitive)
    const headerKeys = Object.keys(rows[0]).map(k => k.toLowerCase());
    const hasGrade = headerKeys.includes('grade');
    const hasColor = headerKeys.includes('color');

    if(!hasGrade) throw new Error('CSV header must include a "grade" column.');
    // color missing is allowed, we'll map to "Unknown"

    // normalize rows: ensure fields accessible
    const normalizedRows = rows.map(r => {
      // find original keys (case-insensitive)
      const obj = {};
      for(const key of Object.keys(r)){
        obj[key.toLowerCase()] = r[key];
      }
      return {
        grade: normalizeName(obj['grade']),
        color: normalizeName(obj['color'] ?? 'Unknown')
      };
    });

    // collect unique grades and colors over the entire CSV (so dataset ordering consistent)
    const gradeSet = new Set();
    const colorSet = new Set();
    normalizedRows.forEach(r => {
      if(r.grade) gradeSet.add(r.grade);
      else gradeSet.add('UnknownGrade');
      colorSet.add(r.color || 'Unknown');
    });

    // sort grades numerically (v0, v1, v2...)
    grades = Array.from(gradeSet).sort((a,b) => {
      const na = gradeToNumber(a), nb = gradeToNumber(b);
      if(na === nb) return a.localeCompare(b);
      return na - nb;
    });

    colors = Array.from(colorSet).sort((a,b) => {
      // Priority order: white, pink, blue, black, orange, purple, green, red, yellow
      const priority = ['white', 'pink', 'blue', 'black', 'orange', 'purple', 'green', 'red', 'yellow'];
      const aIndex = priority.findIndex(p => p.toLowerCase() === a.toLowerCase());
      const bIndex = priority.findIndex(p => p.toLowerCase() === b.toLowerCase());
      
      // If both colors are in priority list, sort by priority
      if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
      // If only 'a' is in priority list, it comes first
      if (aIndex !== -1) return -1;
      // If only 'b' is in priority list, it comes first
      if (bIndex !== -1) return 1;
      // If neither is in priority list, sort alphabetically
      return a.localeCompare(b);
    });

    // initialize counts: counts[grade][color] = 0
    const counts = {};
    grades.forEach(g => {
      counts[g] = {};
      colors.forEach(c => counts[g][c] = 0);
    });

    // build frames cumulatively - one frame per input row (skipping rows lacking grade)
    frames = [];
    normalizedRows.forEach((r, idx) => {
      const g = r.grade || 'UnknownGrade';
      const c = r.color || 'Unknown';

      // if a grade/color appeared that we didn't see in initial pre-scan (unlikely), add them
      if(!(g in counts)){
        grades.push(g);
        counts[g] = {};
        colors.forEach(cc => counts[g][cc] = 0);
      }
      if(!(c in counts[g])){
        // if color is new, add across all grades
        colors.push(c);
        for(const gg of grades) counts[gg][c] = counts[gg][c] || 0;
      }

      // increment
      counts[g][c] = (counts[g][c] || 0) + 1;

      // build dataset arrays: dataset per color, each dataset is an array of values per grade (matching grades order)
      const datasetsPerColor = colors.map(colorName => grades.map(gradeName => counts[gradeName][colorName] || 0));
      frames.push({ datasets: datasetsPerColor, label: `Row ${idx+1}` });
    });

    // now create chart with empty data (0s)
    createChart();
  }

  // --- Chart creation & rendering ---
  function createChart(){
    if(chart) chart.destroy();
    const ctx = canvas.getContext('2d');

    // Calculate the maximum total count for any grade across all frames
    const maxCount = calculateMaxCount();

    // dataset objects (colors) with consistent color assignment
    const datasets = colors.map(c => ({
      label: c,
      data: Array.from({length:grades.length}, () => 0),
      backgroundColor: getColorHex(c),
      borderColor: '#222',
      borderWidth: 0.6,
      borderRadius: 6
    }));

    chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: grades,
        datasets: datasets
      },
      options: {
        indexAxis: 'y', // horizontal bars
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { enabled: true },
          annotation: {
            annotations: {}
          }
        },
        scales: {
          x: { 
            stacked: true, 
            beginAtZero: true, 
            max: maxCount,
            title: { display: true, text: 'Count' } 
          },
          y: { stacked: true, title: { display: true, text: 'Grade' } }
        },
        animation: { duration: 300, easing: 'linear' }
      }
    });
  }

  function calculateMaxCount() {
    if (!frames.length) return 100;
    
    let maxCount = 0;
    
    // Check each frame to find the maximum total count for any grade
    frames.forEach(frame => {
      grades.forEach((grade, gradeIdx) => {
        // Sum all colors for this grade in this frame
        const gradeTotal = frame.datasets.reduce((sum, colorData) => sum + (colorData[gradeIdx] || 0), 0);
        maxCount = Math.max(maxCount, gradeTotal);
      });
    });
    
    // Add a small buffer (10%) to the max count for better visual spacing
    return Math.ceil(maxCount * 1.1);
  }

  function showFrame(i){
    if(!chart || !frames.length) return;
    const frame = frames[i];
    // frame.datasets is [ per color -> array of values per grade ]
    frame.datasets.forEach((valsPerGrade, datasetIdx) => {
      if(chart.data.datasets[datasetIdx]) {
        chart.data.datasets[datasetIdx].data = valsPerGrade.slice();
      } else {
        // extra dataset — add it (shouldn't normally happen)
        chart.data.datasets.push({
          label: colors[datasetIdx] || `c${datasetIdx}`,
          data: valsPerGrade.slice(),
          backgroundColor: getColorHex(colors[datasetIdx] || ''),
          borderColor: '#222',
          borderWidth: 0.6,
          borderRadius: 6
        });
      }
    });
    // ensure labels (grades) in chart match if new grade was added
    chart.data.labels = grades.slice();
    
    // Calculate and update average grade line
    updateAverageGradeLine(i);
    
    // Calculate and update median grade line  
    updateMedianGradeLine(i);
    
    chart.update();
  }

  function updateAverageGradeLine(frameIndex) {
    if (!chart || !frames.length) return;
    
    // Calculate weighted average grade for current frame
    const frame = frames[frameIndex];
    let totalClimbs = 0;
    let weightedSum = 0;
    
    grades.forEach((grade, gradeIdx) => {
      const gradeValue = gradeToNumber(grade);
      if (gradeValue === Number.MAX_SAFE_INTEGER) return; // Skip unknown grades
      
      // Sum all colors for this grade
      const gradeTotal = frame.datasets.reduce((sum, colorData) => sum + (colorData[gradeIdx] || 0), 0);
      totalClimbs += gradeTotal;
      weightedSum += gradeValue * gradeTotal;
    });
    
    const averageGrade = totalClimbs > 0 ? weightedSum / totalClimbs : 0;
    const averageDisplay = totalClimbs > 0 ? `Avg: V${averageGrade.toFixed(1)}` : 'Avg: --';
    
    // Find the closest grade index for positioning
    let closestIndex = 0;
    let closestDiff = Math.abs(gradeToNumber(grades[0]) - averageGrade);
    
    grades.forEach((grade, idx) => {
      const gradeNum = gradeToNumber(grade);
      if (gradeNum !== Number.MAX_SAFE_INTEGER) {
        const diff = Math.abs(gradeNum - averageGrade);
        if (diff < closestDiff) {
          closestDiff = diff;
          closestIndex = idx;
        }
      }
    });
    
    // Update chart annotation - try simpler approach
    chart.options.plugins.annotation.annotations = {
      averageLine: {
        type: 'line',
        yMin: closestIndex,
        yMax: closestIndex,
        borderColor: '#ff4444',
        borderWidth: 3,
        borderDash: [5, 5],
        label: {
          display: true,
          content: averageDisplay,
          position: 'end',
          backgroundColor: '#ff4444',
          color: 'white',
          font: {
            size: 12,
            weight: 'bold'
          },
          padding: 6,
          borderRadius: 4
        }
      }
    };
  }

  // --- Play / Pause ---
  playPauseBtn.addEventListener('click', () => {
    if(!frames.length) return;
    
    if (isPlaying) {
      // Pause
      if(playTimer) { clearInterval(playTimer); playTimer = null; }
      isPlaying = false;
      playPauseBtn.textContent = 'Play';
    } else {
      // Play
      isPlaying = true;
      playPauseBtn.textContent = 'Pause';
      const speed = 15000/frames.length; // Fixed speed for auto-play
      if(playTimer) clearInterval(playTimer);
      playTimer = setInterval(() => {
        showFrame(currentFrame);
        frameSlider.value = currentFrame;
        frameDisplay.textContent = `${currentFrame + 1}/${frames.length}`;
        currentFrame++;
        
        // Pause when we reach the end
        if (currentFrame >= frames.length) {
          currentFrame = frames.length - 1; // Stay on last frame
          clearInterval(playTimer);
          playTimer = null;
          isPlaying = false;
          playPauseBtn.textContent = 'Play';
        }
      }, speed);
    }
  });

  // --- Frame Slider Control ---
  frameSlider.addEventListener('input', () => {
    const frameIndex = parseInt(frameSlider.value);
    currentFrame = frameIndex;
    showFrame(frameIndex);
    frameDisplay.textContent = `${frameIndex + 1}/${frames.length}`;
    
    // Pause animation if playing
    if(playTimer) {
      clearInterval(playTimer);
      playTimer = null;
      isPlaying = false;
      playPauseBtn.textContent = 'Play';
    }
  });

  // Drag & drop support
  window.addEventListener('dragover', e => e.preventDefault());
  window.addEventListener('drop', e => {
    e.preventDefault();
    if(e.dataTransfer.files && e.dataTransfer.files.length){
      csvFileInput.files = e.dataTransfer.files;
      // Trigger the change event to auto-load
      csvFileInput.dispatchEvent(new Event('change'));
    }
  });
  </script>
</body>
</html>